# Hydra
## A Decentralised IRC bot network

#### System requirements specification

### Network Level Architecture
1. Hydra shall be a network of applications across one or more hosts
1. Each individual application connected to the network shall be known as a *node*
1. Nodes shall connect to each other by means of any pre-agreed data protocol
1. Every node shall implement the baseline hydra protocol
1. The hydra protocol shall provide a mechanism to determine a *leader* node
1. Leaders are the nodes responsible for maintaining the *Active Connection* to IRC
1. Events shall be relayed from the Leader, and replies sent to the Leader to be forwarded

### Node Level Design
2. Nodes may be written in any language so long as they can implement a data protocol
2. Nodes must connect to at least one other node in the network
2. Nodes may connect to more than one node in the network
2. Nodes shall be identified by a 32-bit ID (re-)generated on every connect attempt
2. Nodes may also keep a friendly name (*tag*)
2. Nodes must keep a record of all other nodes in the network, and the closest neighbour to them
2. Nodes should endeavor to reply to pings ASAP, lest they timeout if the delay exceeds MAX_PING
2. Nodes may reject any connection attempt as they see fit, e.g. on frequent disconnects
2. Nodes must reject termtime messages from any unregistered node

### Hydra Protocol Messages
#### In-Term (Gossip)
*A leader has been established, transmit data and keepalives*

3. `PING term val id`
  * Heartbeat broadcast by the leader. All nodes must relay this message, and should reply to it
  * `val` (`string`): Identifier for uniqueness. Nodes must not relay the same ping twice
  * `id` (`byte[4]`): NodeID of the Leader node, not modified when relayed by other nodes
3. `PONG term val id count [tag]`
  * Heartbeat reply broadcast from nodes. All nodes must relay these messages
  * `val` (`string`): Identifier for identification
  * `id` (`byte[4]`): NodeID of the origin node, not modified when relayed by other nodes
  * `count` (`int`): Hop counter. Initialized to 0, incremented by each relay
  * `tag` (`string`): Optional, friendly name for the origin node
3. `RECV term idx line`
  * Data broadcast by the leader. All nodes must relay this message
  * `idx` (`int`): Monotonically increasing counter for sorting, initialised to 0 each term
  * `line` (`string`): Unaltered full IRC message of types minimally enumerated by E_RECV
3. `SEND term id line`
  * Data to leader from a node
  * `id` (`byte[4]`): NodeID of the origin node, not modified when relayed by other nodes
  * `line` (`string`): Full IRC message of types minimally enumerated by E_SEND

#### In-Election (Paxos)
*A leader needs to be established, election messages ___only___*

4. `NOMINATE term id`
4. `PLEDGE term id`

#### In-duction (2PC)
*A server has requested to be a node, attempt induction if in-term*

5. `KNOCK id`
  * Induction request sent by a newly linked server. All nodes must relay
  * `id` (`byte[4]`): Proposed NodeID generated by and for the new server
5. `WAVE id` / `SHUN id`
5. `HELLO id [tag]`
5. `WELCOME id`

### Annex A - Definitions
E_RECV :
  `JOIN`, `PART`, `PRIVMSG`, `NOTICE`, `MODE`, `TOPIC`, `QUIT` or `KICK`

E_SEND :
  `JOIN`, `PART`, `PRIVMSG`, `NOTICE`, `MODE`, `TOPIC` or `KICK`

MAX_PING :
  `10` seconds
  
### Annex B - Example Data Protocols
* TCP data over agreed port
* UDP data on agreed port
* IRC message (separate from the active connection)
* FIFO message-passing
